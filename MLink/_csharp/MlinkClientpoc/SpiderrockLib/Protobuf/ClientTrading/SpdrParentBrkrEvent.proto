syntax = "proto3";

import "spiderrock_common.proto";


package spiderrock.protobuf;

import "google/protobuf/timestamp.proto";

/*
    SpdrParentBrkrEvent records are published when a new or cxl/replace parent order arrives causes a broker to begin working and again when a parent order terminates and the underlying broker stops working.  The initial version contains state and market data from just after the initial risk check and first attempt at generating child orders.
*/    
message SpdrParentBrkrEvent {
    message PKey {
        
        int64 parent_number = 10;
        EventRecType rec_type = 11; // type of record [New,Modify,Replace,Close,Reject]
    }


    MessageMetadata _meta = 1;
    
    PKey pkey = 2;
    OptionKey sec_key = 100;
    SpdrKeyType sec_type = 103;
    string accnt = 106;
    SpdrSource spdr_source = 109;
    int64 grouping_code = 112;
    BuySell order_side = 115;
    string client_firm = 118; // SR client firm code
    string alt_accnt = 121; // alternate (client assigned) "long" account string (optional)
    string alt_user_name = 124; // alternate (client assigned) user name (optional)
    uint32 event_number = 127;
    SpdrStageType stage_type = 130; // parent is a staged order [StageLock, StageModify, StageReview]
    int64 base_parent_number = 133; // SPDR order number (initial number in cancel/replace sequence) (also, source parent for dynamically generated orders;eg auto-hedges)
    int64 prev_parent_number = 136; // SPDR order number (order being cancelled/replaced) (zero if none)
    string engine_name = 139; // server stripe
    TickerKey ticker = 142; // SpiderRock underlier stock key
    SpdrBrokerStatus spdr_broker_status = 145;
    SpdrOrderStatus spdr_order_status = 148; // parent order status
    SpdrCloseReason spdr_close_reason = 151; // parent order close reason (if closed)
    SpdrRejectReason spdr_reject_reason = 154; // parent order reject reason (if any)
    string spdr_comment = 157; // additional detail (close/reject reason; last child order error)
    float mar_haircut_utilized1 = 160; // MAR haircut utilized on parent order arrival (riskFirm/riskGroup #1)
    float mar_haircut_utilized2 = 163; // MAR haircut utilized on parent order arrival (riskFirm/riskGroup #2)
    float mar_haircut_utilized3 = 166; // MAR haircut utilized on parent order arrival (riskFirm/riskGroup #3)
    float mar_total_exposure_utilized1 = 169; // MAR totalExposure utilized on parent order arrival (riskFirm/riskGroup #1)
    float mar_total_exposure_utilized2 = 172; // MAR totalExposure utilized on parent order arrival (riskFirm/riskGroup #2)
    float mar_total_exposure_utilized3 = 175; // MAR totalExposure utilized on parent order arrival (riskFirm/riskGroup #3)
    double bid_prc = 178; // bid (nbbo) price @ record publish
    double ask_prc = 181; // ask (nbbo) price @ record publish
    float bid_iVol = 184; // bid (nbbo) ivol @ record publish
    float ask_iVol = 187; // ask (nbbo) ivol @ record publish
    int32 bid_size = 190; // bid size (nbbo cum) @ record publish
    int32 ask_size = 193; // ask size (nbbo cum) @ record publish
    double u_bid = 196; // underlier bid price @ record publish (options only)
    double u_ask = 199; // underlier ask price @ record publish (options only)
    float surface_prc = 202; // SR surface price @ record publish
    float surface_vol = 205; // SR surface volatility @ record publish
    float surface_yrs = 208; // SR surface calc value @ record publish
    float surface_sDiv = 211; // SR surface calc value @ record publish
    float surface_rate = 214; // SR surface calc value @ record publish
    float surface_uPrc = 217; // SR surface calc value @ record publish
    float surface_de = 220; // SR surface calc value @ record publish
    float surface_ga = 223; // SR surface calc value @ record publish
    float surface_th = 226; // SR surface calc value @ record publish
    float surface_ve = 229; // SR surface calc value @ record publish
    float surface_ro = 232; // SR surface calc value @ record publish
    float surface_ph = 235; // SR surface calc value @ record publish
    int32 arrive_nbbo_size = 238; // size of the single largest exchange @ parent order arrival
    OptExch arrive_nbbo_exch = 241; // exchange representing largest size @ order arrival
    int32 arrive_cum_size = 244; // cum size of all exchanges at NBBO price @ parent order arrival
    int32 arrive_num_exch = 247; // num exchanges making up cum size @ parent order arrival
    int32 arrive_limit_size = 250; // immediately marketable size up to limit price on parent order arrival
    double arrive_limit_prc = 253; // expected average fill price if all immediately marketable size executed as advertized
    double avg_fill_prc = 256; // average fill price of all fills attributed parent order
    int32 cum_fill_quan = 259; // cumulative fill quantity attributed to parent order
    uint32 num_child_orders = 262; // total number of child orders generated by this parent broker (parent number)
    uint32 num_day_child_orders = 265; // total number of child orders generated by this parent broker (all day; base parent number)
    int32 open_order_size = 268; // open order size
    int32 action_order_size = 271; // order size available for immediate action (note: not all algo combinations allow immediate action)
    int32 risk_limit_size = 274; // risk limit size (distance to most restrictive risk limit associated with this parent order)
    SpdrRisk risk_limit_desc = 277; // reason for size reduction (identifies the most restrictive risk limit)
    string risk_limit_detail = 280; // addition risk detail
    double limit_ref_uPrc = 283; // effective reference underlier price @ record publish (usually either mid or bid/ask depending on limit type)
    double limit_price = 286; // parent simple prc limit (if any)
    float limit_vol = 289; // parent simple vol limit (if any)
    double make_limit_price = 292; // effective order limit price @ record publish
    LimitError make_limit_err = 295; // limit price error code (if any)
    string make_limit_err_desc = 298; // additional limit price error descriptive text
    double take_limit_price = 301; // effective order limit price @ record publish
    LimitError take_limit_err = 304; // limit price error code (if any)
    string take_limit_err_desc = 307; // additional limit price error descriptive text
    BrokerState broker_state = 310; // broker monitor state
    AlgoState make_state = 313; // [enum] current state of non-marketable order handler (maker)
    AlgoState take_state = 316; // [enum] current state of marketable order handler (taker)
    MktCrossState mkt_cross_state = 319; // [enum] current state of mkt cross handler (if any)
    ChildEvent last_child_event = 322; // most recent child handling event
    SpdrMarketState spdr_mkt_state = 325; // market state code
    int32 num_orders = 328; // number active child orders @ record send
    int32 leaves_qty = 331; // number of active child order contracts (sum of all active child orders) @ record send
    int32 child_order_leaves = 334; // number of open child orders @ record send
    float arrival_sDiv = 337; // effective sdiv rate @ parent order arrival (fixed for life of parent order)
    float arrival_rate = 340; // effective interest rate @ parent order arrival (fixed for life of parent order)
    float arrival_dDiv = 343; // effective cumulative discrete dividend @ parent order arrival (fixed for life of parent order)
    ExpiryKey hedge_sec_key = 346; // auto-hedge sec key
    SpdrKeyType hedge_sec_type = 349; // auto-hedge sec type
    float theo_opx = 352; // option theo prc (from theoVol)
    float theo_vol = 355; // option theo vol (from theoModel;if any)
    uint32 child_order_mask = 358; // bit-mask of all exchange for which a child order was generated
    PriceFormat price_format = 361; // price display format code
    PriceFormat u_price_format = 364; // underlier price display format code
    string user_name = 367; // user associated with the most recent parent order
    google.protobuf.Timestamp timestamp = 370; // timestamp of last modification
}


