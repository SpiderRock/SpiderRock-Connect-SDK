syntax = "proto3";

import "spiderrock_common.proto";


package spiderrock.protobuf;

import "google/protobuf/timestamp.proto";

/*
    SpdrAutoHedgeControl contains autohedge / risk group control details.  Can be uploaded from SRSE, created from ExecutionEngines, or created by SR tools.
    BridgeFromV7:SpdrRiskGroupControl
*/    
message SpdrAutoHedgeControl {
    message PKey {
        
        string accnt = 10;
        int64 risk_group_id = 11; // riskGroupId = 0 means hedgeScope = Accnt
        ExpiryKey hedge_sec_key = 12; // Execution Hedge SecKey (from SpdrParentExecution.hedgeSecKey)
        SpdrKeyType hedge_sec_type = 13; // Execution Hedge SecType (Stock or Future)
        string client_firm = 14;
    }


    MessageMetadata _meta = 1;
    
    PKey pkey = 2;
    string alt_order_id = 103; // alternate order ID (usually clOrdId from client)
    string alt_accnt = 106; // alternate (client assigned) "long" account string (optional) [used to map between client and SR account strings]
    string alt_user_name = 109; // alternate (client assigned) user name (optional) [used to map between client and SR account strings]
    string src_routing_code = 112; // inbound FIX routing code or SRSE/tool server appID (if any)
    string exec_brkr_code = 254; // (optional) override the default execBrkrCode for this order
    string extern_ex_dest = 255; // routing code for orders directed to an external order router (default = null); should match FixRoutingTable.destination (in SR accnt config)
    string extern_params = 121; // external algo names/parameters (usually just an algo name)
    string strategy = 124; // client-supplied strategy string;visible on SpiderRock GUI tools and other order reports.
    string user_name = 127; // name of the user entering the order
    AutoHedge auto_hedge = 130; // auto-hedge algorithm (used for restoring tickets)
    HedgeTarget hedge_target = 133;
    float min_hedge_dDelta = 136; // do not generate autohedge orders if total group $Delta is between [minHedgeDDelta and maxHedgeDDelta] (eg.[-$100,000, +$100,000])
    float max_hedge_dDelta = 139;
    int32 order_size = 142; // initial (and maximum) size of a hedge parent buy or sell order.  note: actual working size will be controlled by the autohedge server based on filled deltas but working size cannot exceed orderSize
    ShortSaleFlag ssale_flag = 145;
    PositionType position_type = 251;
    int32 max_exposure_size = 148; // maximum simultaneous cumulative child order public size exposure (-1 = orderActiveSize) [order can overfill if > orderActiveSize and numMakeExchanges > 1]
    int32 num_make_exchanges = 151; // number of exchanges (1 - 4) on which to publish public making orders.  Effective number might be less than requested number if sufficient exchanges are not available.
    PublicSizeHandling public_size = 154; // public order size handling: None=use default size handling (usually limits public size to 'typical' market size); Randomize=randomize public size; FullSize=expose entire order size where possible
    YesNo can_overlap_cxl_repl = 157; // can execution engines overlap cancel/replace operations [order can overfill if YES] (at most one active overlapping cxl/replace operation for each parent order)
    ProgressRule progress_rule = 160; // Immediate = all size immediately available; TWAP = size released in time intervals;VWAP = size released in volume intervals;TwapForce = size released in intervals/execution forced at the end of interval
    int32 progress_slice_cnt = 163; // number of twap slices to use (default = 4 or 8) [max 20]
    int32 progress_expose_time = 166; // minimum time (secs) to expose order (0 = no minimum; used to guarantee that the order is exposed at mid-market for some time before actively taking)
    float vwap_participation = 169; // target vwap participation rate (target % of trade activity)
    int32 min_mkt_on_close_pct = 172; // Minimum pct [0 - 100] of order reserved for the on-close auction
    float max_make_exch_fee = 175; // maximum making exchange fee (in point value) [zero = no limit; use non-zero number for limit to apply]
    float max_take_exch_fee = 178; // maximum taking exchange fee (in point value) [zero = no limit; use non-zero number for limit to apply]
    IncExchFee inc_take_exch_fee = 181; // include exchange fee in probability
    IncExchFee inc_make_exch_fee = 184; // include exchange fee in probability
    MakeExchRule make_exch_rule = 187; // ActiveMaker exchange preference rule: 'MaxPart' will pick exchanges to maximize participation; 'FeeOrder' will pick exchanges to minimize fees [maximize rebates]; 'ImprvOnly' will only make when improving NBBO.
    int32 max_child_orders = 190; // maximum number of child orders that can be generated by this parent order [order will terminate if/when this cap is reached;zero or neg = unlimited]
    int64 exch_mask = 257; // eligible exchanges (0 = all)
    MarketSession market_session = 252;
    google.protobuf.Timestamp start_dttm = 199; // [optional] (parent order start time)
    int32 order_duration = 202; // [optional] (number of seconds)
    int32 active_duration = 253; // [optional] (number of seconds)
    google.protobuf.Timestamp good_till_dttm = 205; // [optional] (default: 2099-01-01)
    ParentOrderHandling parent_order_handling = 208;
    ParentBalanceHandling parent_balance_handling = 211;
    SpdrLimitType order_limit_type = 214;
    SpdrLimitClass take_limit_class = 217; // Simple = LimitPrice, Probability = BEST(LimitPrice, ProbLimit)
    SpdrLimitClass make_limit_class = 220; // Simple = LimitPrice, Probability = BEST(LimitPrice, ProbLimit)
    YesNo hedge_fill_uMark_lmt_prc = 256; // set a price limit on the autohedge order based on the most recent option fillUMark
    double order_prc_limit = 223; // Applies if LimitType = Prc[]
    double order_prc_offset = 226; // default=0
    StateModel state_model = 229;
    AlphaType take_alpha_type = 232; // Applies if takeLimitClass = Probability
    AlphaType make_alpha_type = 235; // Applies if makeLimitClass = Probability
    float take_alpha_factor = 238; // [-2,+2] takeProbLimit = MAX(takeProbability, takeProbAvg + takeAlphaFactor * takeProbStd) [if AlphaType = Relative]
    float make_alpha_factor = 241; // [-2,+2] makeProbLimit = MAX(makeProbability, makeProbAvg + makeAlphaFactor * makeProbStd) [if AlphaType = Relative]
    float take_probability = 244; // takeProbLimit = takeProbability [if AlphaType = Static]
    float make_probability = 247; // makeProbLimit = makeProbability [if AlphaType = Static]
    google.protobuf.Timestamp timestamp = 250; // record timestamp
}


